// tests/array-tests.cpp
#include "MPackArray.h"
#include "objects/ArrayObjects.h"
#include <cstdint>
#include <gtest/gtest.h>
#include <string>

// --- harness
static ObjectWithArrays parseArrays(const uint8_t* data, size_t len) {
    mpack_reader_t r;
    mpack_reader_init_data(&r, (const char*) data, len);
    ObjectWithArrays obj;
    obj.read(r, 0);
    EXPECT_EQ(mpack_reader_destroy(&r), mpack_ok);
    auto err = mpack_reader_error(&r);
    std::cout << "mpack_reader_error = " << mpack_error_to_string(err) << " (" << err << ")" << std::endl;
    return obj;
}

struct ArrayCase {
    std::string name;
    std::vector<uint8_t> bytes;
    std::vector<int64_t> i64;
    std::vector<uint64_t> u64;
    std::vector<float> f32;
    std::vector<double> f64;
    std::vector<std::string> ss;
    std::vector<std::pair<int32_t, uint32_t>> objs;
    std::vector<std::vector<int32_t>> aa;
};

class ObjectWithArraysTest : public ::testing::TestWithParam<ArrayCase> {};

TEST_P(ObjectWithArraysTest, DecodesAllArrays) {
    const auto& tc = GetParam();
    auto obj = parseArrays(tc.bytes.data(), tc.bytes.size());
    ASSERT_EQ(obj.i64.size, tc.i64.size());
    ASSERT_EQ(obj.u64.size, tc.u64.size());
    ASSERT_EQ(obj.f32.size, tc.f32.size());
    ASSERT_EQ(obj.f64.size, tc.f64.size());
    ASSERT_EQ(obj.ss.size, tc.ss.size());
    ASSERT_EQ(obj.objs.size, tc.objs.size());
    ASSERT_EQ(obj.aa.size, tc.aa.size());
    for (size_t i = 0; i < tc.i64.size(); ++i)
        EXPECT_EQ(obj.i64[i], tc.i64[i]);
    for (size_t i = 0; i < tc.u64.size(); ++i)
        EXPECT_EQ(obj.u64[i], tc.u64[i]);
    for (size_t i = 0; i < tc.f32.size(); ++i)
        EXPECT_FLOAT_EQ(obj.f32[i], tc.f32[i]);
    for (size_t i = 0; i < tc.f64.size(); ++i)
        EXPECT_DOUBLE_EQ(obj.f64[i], tc.f64[i]);
    for (size_t i = 0; i < tc.ss.size(); ++i)
        EXPECT_EQ(obj.ss[i], tc.ss[i]);
    for (size_t i = 0; i < tc.objs.size(); ++i) {
        ASSERT_NE(obj.objs[i], nullptr);
        EXPECT_EQ(obj.objs[i]->a, tc.objs[i].first);
        EXPECT_EQ(obj.objs[i]->b, (uint32_t) tc.objs[i].second);
    }
    for (size_t i = 0; i < tc.aa.size(); ++i) {
        ASSERT_EQ(obj.aa[i].size, tc.aa[i].size());
        for (size_t j = 0; j < tc.aa[i].size(); ++j)
            EXPECT_EQ(obj.aa[i][j], tc.aa[i][j]);
    }
}

// --- your exact hex ---
static std::vector<uint8_t> bytes_arrays_case1 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x93, 0x01, 0xFE, 0xCD, 0x01, 0x2C, 0xA3, 0x75, 0x36, 0x34, 0x93, 0x00, 0xCE,
    0x00, 0x01, 0x5F, 0x90, 0xCB, 0x41, 0xFA, 0x13, 0xB8, 0x60, 0x00, 0x00, 0x00, 0xA3, 0x66, 0x33, 0x32, 0x92,
    0xCB, 0x40, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xBF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA3, 0x66, 0x36, 0x34, 0x92, 0xD2, 0xB6, 0xAF, 0xB0, 0x80, 0xCB, 0x44, 0xDF, 0xE1, 0x85, 0xCA, 0x57, 0xC5,
    0x17, 0xA2, 0x73, 0x73, 0x93, 0xA5, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0xA9, 0x55, 0x54, 0x46, 0x2D, 0x38, 0x20,
    0xE2, 0x9C, 0x93, 0xA0, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x92, 0x82, 0xA1, 0x61, 0xF6, 0xA1, 0x62, 0x14, 0x82,
    0xA1, 0x61, 0x00, 0xA1, 0x62, 0x2A, 0xA2, 0x61, 0x61, 0x92, 0x93, 0x01, 0x02, 0x03, 0x92, 0xFC, 0xFB};

static std::vector<uint8_t> bytes_arrays_case2 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x95, 0xFF, 0x02, 0xFD, 0x04, 0xFB, 0xA3, 0x75, 0x36, 0x34, 0x95, 0x01, 0x02,
    0x03, 0x04, 0x05, 0xA3, 0x66, 0x33, 0x32, 0x94, 0x01, 0xFF, 0xCB, 0x3F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xCB, 0xC0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x66, 0x36, 0x34, 0x94, 0xCB, 0x40, 0x09,
    0x21, 0xFB, 0x54, 0x44, 0x2D, 0x18, 0x00, 0xCB, 0x01, 0xA5, 0x6E, 0x1F, 0xC2, 0xF8, 0xF3, 0x59, 0xCB, 0x7E,
    0x37, 0xE4, 0x3C, 0x88, 0x00, 0x75, 0x9C, 0xA2, 0x73, 0x73, 0x92, 0xD9, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F,
    0x6C, 0x73, 0x20, 0x21, 0x40, 0x23, 0x24, 0x20, 0x22, 0x71, 0x75, 0x6F, 0x74, 0x65, 0x22, 0x20, 0x5C, 0x20,
    0x62, 0x61, 0x63, 0x6B, 0x73, 0x6C, 0x61, 0x73, 0x68, 0xAE, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x6C, 0x69, 0x6E,
    0x65, 0x0A, 0x74, 0x65, 0x78, 0x74, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x91, 0x82, 0xA1, 0x61, 0x7B, 0xA1, 0x62,
    0xCD, 0x01, 0xC8, 0xA2, 0x61, 0x61, 0x93, 0x90, 0x91, 0x0A, 0x92, 0x14, 0x1E};

// case3: only i64 filled
static std::vector<uint8_t> bytes_arrays_case3 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x93, 0x01, 0xFE, 0x03, 0xA3, 0x75, 0x36, 0x34, 0x90, 0xA3, 0x66, 0x33, 0x32, 0x90,
    0xA3, 0x66, 0x36, 0x34, 0x90, 0xA2, 0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61, 0x61, 0x90};

// case4: only u64 filled
static std::vector<uint8_t> bytes_arrays_case4 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x92, 0x00, 0xCF, 0x11, 0x22,
    0x10, 0xF4, 0x7D, 0xE9, 0x81, 0x15, 0xA3, 0x66, 0x33, 0x32, 0x90, 0xA3, 0x66, 0x36, 0x34,
    0x90, 0xA2, 0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61, 0x61, 0x90};

// case5: only f32 filled
static std::vector<uint8_t> bytes_arrays_case5 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x90, 0xA3, 0x66, 0x33, 0x32, 0x93,
    0xCB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCB, 0xC0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x66, 0x36, 0x34, 0x90,
    0xA2, 0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61, 0x61, 0x90};

// case6: only f64 filled
static std::vector<uint8_t> bytes_arrays_case6 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x90, 0xA3, 0x66, 0x33, 0x32, 0x90, 0xA3, 0x66,
    0x36, 0x34, 0x92, 0xCB, 0x2B, 0x2B, 0xFF, 0x2E, 0xE4, 0x8E, 0x05, 0x30, 0xCB, 0xD4, 0xB2, 0x49, 0xAD, 0x25,
    0x94, 0xC3, 0x7D, 0xA2, 0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61, 0x61, 0x90};

// case7: only ss filled
static std::vector<uint8_t> bytes_arrays_case7 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x90, 0xA3, 0x66, 0x33, 0x32,
    0x90, 0xA3, 0x66, 0x36, 0x34, 0x90, 0xA2, 0x73, 0x73, 0x92, 0xA8, 0x6F, 0x6E, 0x6C, 0x79,
    0x2D, 0x6F, 0x6E, 0x65, 0xA0, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61, 0x61, 0x90};

// case8: only objs filled
static std::vector<uint8_t> bytes_arrays_case8 = {
    0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x90, 0xA3, 0x66, 0x33, 0x32, 0x90, 0xA3,
    0x66, 0x36, 0x34, 0x90, 0xA2, 0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x92, 0x82, 0xA1, 0x61,
    0x01, 0xA1, 0x62, 0x02, 0x82, 0xA1, 0x61, 0xFD, 0xA1, 0x62, 0x04, 0xA2, 0x61, 0x61, 0x90};

// case9: only aa filled
static std::vector<uint8_t> bytes_arrays_case9 = {0x87, 0xA3, 0x69, 0x36, 0x34, 0x90, 0xA3, 0x75, 0x36, 0x34, 0x90,
                                                  0xA3, 0x66, 0x33, 0x32, 0x90, 0xA3, 0x66, 0x36, 0x34, 0x90, 0xA2,
                                                  0x73, 0x73, 0x90, 0xA4, 0x6F, 0x62, 0x6A, 0x73, 0x90, 0xA2, 0x61,
                                                  0x61, 0x93, 0x93, 0x01, 0x02, 0x03, 0x90, 0x91, 0xFF};

struct ArrayCaseName {
    template <class ParamType> std::string operator()(const ::testing::TestParamInfo<ParamType>& info) const {
        // Give each case a readable name
        return info.param.name;
    }
};

INSTANTIATE_TEST_SUITE_P(
    MPackAllArrays, ObjectWithArraysTest,
    ::testing::Values(ArrayCase{"MixOfAllArrays1",
                                bytes_arrays_case1,
                                {1, -2, 300},
                                {0ULL, 90000ULL, 7000000000ULL},
                                {3.25f, -0.5f},
                                {-1230000000.0, 6.02214076e23},
                                {"hello", "UTF-8 âœ“", ""},
                                {{-10, 20u}, {0, 42u}},
                                {{1, 2, 3}, {-4, -5}}},
                      ArrayCase{"MixOfAllArrays2",
                                bytes_arrays_case2,
                                {-1, 2, -3, 4, -5},
                                {1ULL, 2ULL, 3ULL, 4ULL, 5ULL},
                                {1.0f, -1.0f, 1.5f, -2.75f},
                                {3.141592653589793, 0.0, 1e-300, 1e300},
                                {"symbols !@#$ \"quote\" \\ backslash", "multiline\ntext"},
                                {{123, 456u}},
                                {{}, {10}, {20, 30}}},
                      // case3: only i64
                      ArrayCase{"ArrayOfI64", bytes_arrays_case3, {1, -2, 3}, {}, {}, {}, {}, {}, {}},
                      // case4: only u64
                      ArrayCase{
                          "ArrayOfU64", bytes_arrays_case4, {}, {0ULL, 1234567890123456789ULL}, {}, {}, {}, {}, {}},
                      // case5: only f32
                      ArrayCase{"ArrayOfFloats", bytes_arrays_case5, {}, {}, {0.0f, 1.0f, -2.5f}, {}, {}, {}, {}},
                      // case6: only f64
                      ArrayCase{"ArrayOfDoubles", bytes_arrays_case6, {}, {}, {}, {1.0e-100, -1.0e100}, {}, {}, {}},
                      // case7: only ss
                      ArrayCase{"ArrayOfStrings", bytes_arrays_case7, {}, {}, {}, {}, {"only-one", ""}, {}, {}},
                      // case8: only objs
                      ArrayCase{"ArrayOfObjects", bytes_arrays_case8, {}, {}, {}, {}, {}, {{1, 2u}, {-3, 4u}}, {}},
                      // case9: only aa
                      ArrayCase{"ArrayOfArrays", bytes_arrays_case9, {}, {}, {}, {}, {}, {}, {{1, 2, 3}, {}, {-1}}}),
    ArrayCaseName());
